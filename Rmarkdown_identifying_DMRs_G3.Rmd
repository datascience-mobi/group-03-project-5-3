---
title: "Identifying DMRs G3"
author: "Leo Burmedi, Pierre De Marinis, Konstantin Fischer, Daniel Ãœrge"
date: "6/10/2019"
output: html_document
---

# $\color{blue}{\text{Introduction}}$

> Differentially methylated regions (DMRs) ... 

## Loading the data and naming the frames.
```{r, echo=TRUE} 
AML_Mono_list <- readRDS("~/Heidelberg/Uni/FS4 2019/Bioinfo/AMLvsMono/AML_Mono_list.RDS")
input_data <- AML_Mono_list
genes_data_framexy <- input_data$genes
promoters_data_framexy <- input_data$promoters
cpgislands_data_frame <- input_data$cpgislands
tiling_data_frame <- input_data$tiling
remove(tiling_data_frame, cpgislands_data_frame, input_data, AML_Mono_list)
```

> From these datasets only the genes and the promoters will be relevant for the analysis, so we can remove the others. The reason is that only promoters and genes  directly influence the gene expression for certain and in the end we want to find differences in the gene expression between the two cohorts.   

# $\color{blue}{\text{Quality control}}$

> The goal of Qualtity control is to make the dataset as suited as possible for the analyis. This includes:Removing uncessary variables, getting rid NAs, removing information that can produce fallicous results.

## Removing chromosome X and Y.

> Chromosome X is removed because of hypermethylation and chromosome Y because of lack of male patients.

```{r, echo = TRUE}
# Removing chromosome X and Y.
    genes_data_frame <- data.frame(genes_data_framexy[!(genes_data_framexy$Chromosome == "chrX" | genes_data_framexy$Chromosome == "chrY"),])
    promoters_data_frame <-     data.frame(promoters_data_framexy[!(promoters_data_framexy$Chromosome == "chrX" | promoters_data_framexy$Chromosome == "chrY"),])
    remove(genes_data_framexy, promoters_data_framexy)
```

## Distribution of beta values by healty and AML patients.

> First we need to check if we can find DMRs at all. Finding DMRs is only possible if the distributions of beta values differ between AML and healty patients so we need to check this.  

```{r, echo = TRUE} 
# Creating dataframes for genes and prmoters with all beta values not without NAs.
    g_AML_bedall <- data.frame(Beta = c(t(na.omit(genes_data_frame[,11:20]))))
    g_Mono_bedall <- data.frame(Beta = c(t(na.omit(genes_data_frame[,21:30]))))
    p_AML_bedall <- data.frame(Beta = c(t(na.omit(promoters_data_frame[,11:20]))))
    p_Mono_bedall <- data.frame(Beta = c(t(na.omit(promoters_data_frame[,21:30]))))
```

#### Distribution of all beta values by AML or Mono patiens in the genes and promoters dataset.
```{r, echo = TRUE}
par(mfrow=c(1, 2))    
    hist(g_Mono_bedall$Beta, main = "Distribution beta Mono genes", xlab = "beta value", col = "forestgreen", breaks = 50, ylim = c(0, 80000))
    hist(g_AML_bedall$Beta, main = "Distribution beta AML genes", xlab = "beta value", col = "red", breaks = 50)
```  

```{r, echo = TRUE}
    par(mfrow=c(1, 2))    
    hist(p_Mono_bedall$Beta, main = "Distribution beta Mono promoters", xlab = "beta value", col = "forestgreen", breaks = 50, ylim = c(0, 80000))
    hist(p_AML_bedall$Beta, main = "Distribution beta AML promoters", xlab = "beta value", col = "red", breaks = 50)
```  

> It can be seen for both promoters and genes, that the two plots have a slightly different distribution. This confirms the assumption that we might find DMRs for both datasets. 

## Removing unnecessary variables

> For the analysis we only need the beta and the coverage values of the patients.

```{r, echo=TRUE}
    g_patients <- data.frame(genes_data_frame[11:50])
    p_patients <- data.frame(promoters_data_frame[11:50])
```

## Setting coverage thresholds and handling NAs

> If the coverage values is too low that means the given sequence wasn't properly amplified. If it is too high however that might be due to the overlap of repeated sequences.  This can render our analysis unreliable so we need to find sensible thresholds. The lower coverage threshold was set by 25 based on literature. For the higher however we came up with the solution to find the value where we would loose the lowest percentage of data by loosing the highest percentage of coverage values. To check if this is even possible we made two plots to evalueate the function. Since the two datasets have a different distribution we need to find seperate upper thresholds.

> Once we find the threshold we will convert all beta values with an unrelaible corresponding coverage value to NAs. Next we will remove all lines with a more than 3 NAs for one cohort.

```{r,  echo=TRUE} 
    # Creating data frames with all coverage values by genes and promoters
    g_coverage_all <- data.frame(Coverage = c(t(genes_data_frame[,31:50])))
    p_coverage_all <- data.frame(Coverage = c(t(promoters_data_frame[,31:50])))
```

### Drawing a "if we make this the maximum coverage value we keep this % of objects" plot.

```{r, echo = TRUE}
    Y = seq(0, 200000, 1)
    Q = ecdf(g_coverage_all$Coverage) (Y)
    plot(Y, Q, type = "n", main = "Quantiles for coverage values by genes", xlab = "Coverage value", ylab = "Quantile")
    lines(Y, Q)
```


```{r, echo = TRUE}
    Y = seq(0, 200000, 1)
    Q = ecdf(p_coverage_all$Coverage) (Y)
    plot(Y, Q, type = "n", main = "Quantiles for coverage values by promoters", xlab = "Coverage value", ylab = "Quantile")
    lines(Y, Q)
```

> The curves for both datasets have a very rapid increase by lower values and then  functions. So this confirms that we can use our above mentioned method and loose a very high percentage of data by cutting at a relatively low value and we can proceed with the anlyis. 

### Finding the upper threshold

> For finding the upper thresfold we used the hyperloop. The hyperloop calculates the amount of lines, which would remain if we were to cut at a given coverage value. 

[CODE FOR HYPERLOOP]
[PLOT]

> Now we plotted the results and aimed to find the highest alteration of the slope. To determine this we used the kneedle algorithm. 

[KNEEDLE CODE]
[PLOT]

#### Setting the unreliable values to NAs
> Now that the thresholds are identified the beta values with a corresponding  coverage value <25 and > 98525 for genes will be set to NAs. For prmoters we used <25 and > 14175 as thresholds based on the kneedle analyisis as well.

```{r}
# Loop for setting unreliable values to NAs by genes.
for (j in 21:40) {
  for (i in 1:nrow(g_patients)) {
    
    if(g_patients[i,j] < 25 | g_patients[i,j] >= 98525){
      g_patients[i,j-20] <- NA
    }
  }
}

# Loop for setting unreliable values to NAs by promoters.
for (j in 21:40) {
  for (i in 1:nrow(p_patients)) {
    
    if(p_patients[i,j] < 25 | p_patients[i,j] >= 14175){
      p_patients[i,j-20] <- NA
    }
  }
}
```

> Next the lines with more than 3 NAs for at least in patient group will be removed since these genes or promoters are unrelaible. 

```{r}
# Removing lines with more than 3 NAs for at least one cohort. 
genes_clean <- g_patients[!(rowSums(is.na(g_patients[1:10])) > 3 | 
                              rowSums(is.na(g_patients[11:20])) > 3),  ]
promoters_clean <- p_patients[!(rowSums(is.na(p_patients[1:10])) > 3 | 
                                  rowSums(is.na(p_patients[11:20])) > 3),  ]

remove(g_patients, p_patients, i, j)
```

# $\color{blue}{\text{Normalization and Imputation}}$

## Normalization 
> In oder to be able to perform a Student t-test later we need to nomalize the data. This was done by converting the beta values to M values. This has many advantages: M values have a normal distribution, range from infinity to negative infinity and the M values have a stable variance. 

> Eqation for imputation: $M =\log_{2}(\frac{\beta}{1-\beta})$

### Code for normalization
```{r}
genes_clean_reduced <- genes_clean[,1:20]
promoters_clean_reduced <- promoters_clean[,1:20]

# Since 0 and 1 render no results we used 0.0000000001, 0.9999999999 respectively in the calculation instead.
f_BetaToM <- function(x) {
  
  if(!(is.na(x))){
    
    if(x == 1){
      x <- 0.9999999999
    }
    
    if(x == 0) {
      x <- 0.0000000001
    }
    
    x = log2(x / (1 - x))
  }
  
  return(x)
}

g_M_NA <- apply(genes_clean_reduced, c(1,2), f_BetaToM)
g_M_NA <- data.frame(g_M_NA)

p_M_NA <- apply(promoters_clean_reduced, c(1,2), f_BetaToM)
p_M_NA <- data.frame(p_M_NA)
```

## Imputation
> At this point still many NAs remain in the datassets, so we want to handle them. We could either get rid of all lines which still include NAs, or impute them. In order to keep as much information as possible we decided to impute the NAs. There are multiple models to do this and we tested out some on our data to find the best one. The reason we decided to impute after the normalization is...

### Imputation models
